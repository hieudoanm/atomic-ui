{
  "pageProps": {
    "code": "import { CSSProperties, JSX, KeyboardEvent, ReactNode, useCallback, useEffect, useRef, useState } from 'react';\n\nexport interface Column<T> {\n  key: keyof T;\n  label: string;\n  width?: string;\n}\n\ninterface VirtualTableProps<T> {\n  columns: Column<T>[];\n  data: T[];\n  rowHeight: number;\n  height: number;\n  renderCell?: (item: T, column: Column<T>, rowIndex: number, isSelected: boolean) => ReactNode;\n}\n\nexport const VirtualTable = <T,>({\n  columns,\n  data,\n  rowHeight,\n  height,\n  renderCell,\n}: VirtualTableProps<T>): JSX.Element => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const [scrollTop, setScrollTop] = useState<number>(0);\n\n  // Instead of a single selected index, we keep a set of selected row indexes\n  const [selectedIndexes, setSelectedIndexes] = useState<Set<number>>(new Set());\n\n  // Track the \"anchor\" index for shift-selection range\n  const [anchorIndex, setAnchorIndex] = useState<number | null>(null);\n\n  const totalHeight = data.length * rowHeight;\n  const visibleCount = Math.ceil(height / rowHeight);\n  const startIndex = Math.floor(scrollTop / rowHeight);\n  const endIndex = Math.min(startIndex + visibleCount + 1, data.length);\n  const visibleRows = data.slice(startIndex, endIndex);\n\n  const handleScroll = useCallback(() => {\n    if (containerRef.current) {\n      setScrollTop(containerRef.current.scrollTop);\n    }\n  }, []);\n\n  const scrollToRow = (index: number) => {\n    if (!containerRef.current) return;\n    const container = containerRef.current;\n    const currentScrollTop = container.scrollTop;\n    const rowTop = index * rowHeight;\n    const rowBottom = rowTop + rowHeight;\n\n    if (rowTop < currentScrollTop) {\n      container.scrollTop = rowTop;\n    } else if (rowBottom > currentScrollTop + height) {\n      container.scrollTop = rowBottom - height;\n    }\n  };\n\n  // Select rows between two indexes (inclusive)\n  const selectRange = (start: number, end: number) => {\n    const rangeStart = Math.min(start, end);\n    const rangeEnd = Math.max(start, end);\n    const newSelection = new Set(selectedIndexes);\n    for (let i = rangeStart; i <= rangeEnd; i++) {\n      newSelection.add(i);\n    }\n    return newSelection;\n  };\n\n  // Keyboard navigation with multi-select support (Shift)\n  const handleKeyDown = (e: KeyboardEvent<HTMLDivElement>) => {\n    if (data.length === 0) return;\n\n    // Get current focused index; if none, fallback to first selected or 0\n    const focusedIndex =\n      anchorIndex !== null ? anchorIndex : selectedIndexes.size > 0 ? Math.min(...selectedIndexes) : 0;\n\n    if (e.key === 'ArrowDown') {\n      e.preventDefault();\n      const next = Math.min(focusedIndex + 1, data.length - 1);\n      if (e.shiftKey) {\n        // extend selection range\n        setSelectedIndexes(selectRange(anchorIndex ?? next, next));\n      } else {\n        setSelectedIndexes(new Set([next]));\n        setAnchorIndex(next);\n      }\n      scrollToRow(next);\n      setAnchorIndex(next);\n    }\n\n    if (e.key === 'ArrowUp') {\n      e.preventDefault();\n      const prev = Math.max(focusedIndex - 1, 0);\n      if (e.shiftKey) {\n        setSelectedIndexes(selectRange(anchorIndex ?? prev, prev));\n      } else {\n        setSelectedIndexes(new Set([prev]));\n        setAnchorIndex(prev);\n      }\n      scrollToRow(prev);\n      setAnchorIndex(prev);\n    }\n  };\n\n  // Mouse click supports multi-selection with Shift and Ctrl/Cmd keys\n  const handleRowClick = (rowIndex: number, e: React.MouseEvent) => {\n    const isCtrlPressed = e.ctrlKey || e.metaKey;\n    const isShiftPressed = e.shiftKey;\n\n    if (isShiftPressed && anchorIndex !== null) {\n      // Shift + click: select range between anchor and clicked row\n      setSelectedIndexes(selectRange(anchorIndex, rowIndex));\n    } else if (isCtrlPressed) {\n      // Ctrl/Cmd + click: toggle single row selection\n      setSelectedIndexes((prev) => {\n        const newSelection = new Set(prev);\n        if (newSelection.has(rowIndex)) {\n          newSelection.delete(rowIndex);\n        } else {\n          newSelection.add(rowIndex);\n        }\n        return newSelection;\n      });\n      setAnchorIndex(rowIndex);\n    } else {\n      // Normal click: select only clicked row\n      setSelectedIndexes(new Set([rowIndex]));\n      setAnchorIndex(rowIndex);\n    }\n    scrollToRow(rowIndex);\n  };\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n    container.addEventListener('scroll', handleScroll);\n    return () => container.removeEventListener('scroll', handleScroll);\n  }, [handleScroll]);\n\n  return (\n    <div\n      className=\"overflow-hidden rounded-lg border border-neutral-200 dark:border-neutral-800\"\n      tabIndex={0}\n      onKeyDown={handleKeyDown}\n      role=\"grid\"\n      aria-rowcount={data.length}\n      aria-colcount={columns.length}>\n      <table className=\"w-full border-collapse\" role=\"rowgroup\">\n        <thead>\n          <tr>\n            {columns.map((col) => (\n              <th\n                key={String(col.key)}\n                className=\"border-b border-neutral-200 bg-neutral-100 p-2 text-left dark:border-neutral-800 dark:bg-neutral-900\"\n                style={{ width: col.width ?? 'auto' }}\n                role=\"columnheader\">\n                {col.label}\n              </th>\n            ))}\n          </tr>\n        </thead>\n      </table>\n\n      <div\n        ref={containerRef}\n        className=\"relative overflow-y-auto focus:outline-none\"\n        style={{ height }}\n        role=\"rowgroup\">\n        <div className=\"relative\" style={{ height: totalHeight }}>\n          {visibleRows.map((row, i) => {\n            const rowIndex = startIndex + i;\n            const isSelected = selectedIndexes.has(rowIndex);\n\n            const style: CSSProperties = {\n              position: 'absolute',\n              top: rowIndex * rowHeight,\n              height: rowHeight,\n              left: 0,\n              right: 0,\n              display: 'table',\n              width: '100%',\n              tableLayout: 'fixed',\n              background: isSelected ? '#e2e8f0' : undefined,\n              cursor: 'pointer',\n            };\n\n            return (\n              <div\n                key={rowIndex}\n                style={style}\n                onClick={(e) => handleRowClick(rowIndex, e)}\n                role=\"row\"\n                aria-selected={isSelected}\n                tabIndex={-1}>\n                <table className=\"w-full border-collapse\" role=\"presentation\">\n                  <tbody>\n                    <tr>\n                      {columns.map((col) => (\n                        <td\n                          key={String(col.key)}\n                          className=\"border-b border-neutral-200 p-2 text-left dark:border-neutral-800\"\n                          style={{ width: col.width ?? 'auto' }}\n                          role=\"gridcell\">\n                          {renderCell ? renderCell(row, col, rowIndex, isSelected) : String(row[col.key])}\n                        </td>\n                      ))}\n                    </tr>\n                  </tbody>\n                </table>\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    </div>\n  );\n};\n"
  },
  "__N_SSG": true
}
